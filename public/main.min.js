'use strict';

const exclude = [
  "constructor"
];

class BaseObject {
  constructor(){
    this.init();
  }
  
  init(){
  }

  getAllProperties(){
    var props = {},
      self = this;
    Object.getOwnPropertyNames(self).forEach( (prop) => {
      if ( typeof self[prop] !== "function" ){
        props[prop] = self[prop];
      }
    } );
    return props;
  }

  hasProperty(propName){
    return Object.keys(this.getAllProperties()).indexOf(propName) >= 0;
  }

  getAllMethods(){
    var props = [],
      self = this;
    Object.getOwnPropertyNames(self).forEach( (prop) => {
      if ( typeof self[prop] === "function" ){
        props.push(prop);
      }
    } );
    var ref = Object.getPrototypeOf(self);
    while ( ref ){
      Object.getOwnPropertyNames(ref.constructor.prototype).forEach( (prop) => {
        if ( props.indexOf(prop) < 0 && exclude.indexOf(prop) < 0 ){
          props.push(prop);
        }
      } );
      ref = Object.getPrototypeOf(ref);
      if ( ref === Object.prototype ) break;
    }
    return props.sort();
  }

  hasMethod(propName){
    return this.getAllMethods().indexOf(propName) >= 0;
  }
}
/**
 * Static method access for prototype method getAllProperties
 *
 * @param  objectRef OBJECT the referenced object whose properties
 *                          are being returned
 * @return ARRAY the names of all properties
 */
BaseObject.getAllProperties = (objectRef) => {
  return BaseObject.prototype.getAllProperties.call(objectRef);
};

/**
 * Static method access for prototype method getAllMethods
 *
 * @param  objectRef OBJECT the referenced object whose methods
 *                          are being returned
 * @return ARRAY the names of all methods
 */
BaseObject.getAllMethods = (objectRef) => {
  return BaseObject.prototype.getAllMethods.call(objectRef);
};

const attachMethod = function(owner, methodName, parent){
  owner[methodName] = function(){
    var args = [];
    args.push(parent);
    Array.prototype.slice.call(arguments).forEach( (arg) => {
      args.push(arg);
    } );
    return parent[methodName].apply(owner, args);
  };
};

class Behavior extends BaseObject {

  constructor(){
    super();
    this.getBehaviorOwner = () => null;
    this.isBehaviorAttached = () => this.getBehaviorOwner() !== null;
    this.detachBehavior = () => undefined;
  }

  attachBehavior(component){
    var self = this,
      owner = component,
      attachedPropNames = [], 
      methods = BaseObject.prototype.getAllMethods.call(self),
      ownerMethods = BaseObject.prototype.getAllMethods.call(owner),
      methodName;

    for( methodName in methods ){
      methodName = methods[methodName];
      switch ( methodName ){
        case "constructor":
        case "init":
        case "attachBehavior":
        case "detachBehavior":
        case "isBehaviorAttached":
        case "getBehaviorOwner":
          continue;
      }
      if ( ownerMethods.indexOf(methodName) >= 0 ) continue;
      if ( typeof self[methodName] === "function" ){
        attachMethod(owner, methodName, this);
        attachedPropNames.push(methodName);
      }
    } 

    this.getBehaviorOwner = () => owner;

    this.detachBehavior = () => {
      attachedPropNames.forEach( (propName, index) => {
        delete owner[propName];
      } );
      owner = null;
    };
  }
}

/**
 * Adds BaseObject properties to a component that
 * hasn't extends BaseObject
 */
class BaseObjectBehavior extends Behavior {

  getAllProperties(behavior){
    return BaseObject.prototype.getAllProperties.call(this);
  }
  
  hasProperty(behavior, propName){
    return BaseObject.prototype.hasProperty.call(this, propName);
  }

  getAllMethods(behavior){
    return BaseObject.prototype.getAllMethods.call(this);
  }

  hasMethod(behavior, methodName){
    return BaseObject.prototype.hasMethod.call(this, methodName);
  }

}

class Focusable extends Behavior {
  init(){
    super.init();
    this.focusableItem = null;
  }

  setFocusItem(behavior, component){
    if ( component ){
      behavior.focusableItem = component;
    }
  }

  focus(behavior){
    if ( behavior.focusableItem !== null ){
      var item = $(behavior.focusableItem);
      if ( item && item.length ){
        item.focus();
      }
    }
  }

  hasFocus(behavior){
    if ( behavior.focusableItem !== null ){
      var item = $(behavior.focusableItem);
      if ( item && item.length ){
        return item.is(":focus");
      }
    }
    return false;
  };
}

class TestClass {
  constructor(){
    this.type = "test-type";
  }

  getName(){
    return "Test Class";
  }

  addBehaviors(){
    var behavior = new Focusable(),
      base = new BaseObjectBehavior();

    base.attachBehavior(this);
    behavior.attachBehavior(this);

    this.behaviorRef = behavior;
    this.baseRef = base;
  }

  removeBehaviors(){
    if ( this.behaviorRef ){
      this.behaviorRef.detachBehavior();
    }
    if ( this.baseRef ){
      this.baseRef.detachBehavior();
    }
  }
}
var test = new TestClass();

console.log("Pre Attachment Methods");
console.log(BaseObject.getAllMethods(test));
test.addBehaviors();
console.log("Methods after attaching behaviors");
console.log(test.getAllMethods());
console.log("Check if focus method exists");
console.log(test.hasMethod("focus"));
console.log("Methods after removing behaviors");
test.removeBehaviors();
console.log(BaseObject.getAllMethods(test));
